## Seminar 6. TrueTime. Снимки в LSM

#### TrueTime вместо коммуникации

Вернёмся к алгоритму ABD - репликации ячейки памяти - который для выбора глобально монотонных $ts$ использовал лишнюю фазу коммуникации в операциях. Рассмотрим, как при помощи TrueTime и без коммуникации реплик можно получить $` w_1 \prec_{rt} w_2 => ts \left \lparen w_1 \right \rparen \lt ts \left \lparen w_2 \right \rparen `$. В действительности присутствует косвенная асинхронная коммуникация через Тайм-мастеров и GPS спутники

Не нужно думать о двух операциях, своей и чужой, и как их упорядочить по логическим часам, нужно думать лишь о своей. По определению линеаризации достаточно выбрать точку на отрезке протекания операции, которая и даст $ts$. Но мы не можем её выбрать, поскольку не знаем начала операции, и TT не даёт конкретного времени, лишь диапазон. Поэтому сделаем наоборот и окончим операцию так, чтобы туда попала известная нам метка

Пусть операция $o$ началась в неизвестное время $t_1$. Вызовем $` TT.Now \left \lparen \right \rparen \to \left \lbrack e, l \right \rbrack `$ в некоторый момент времени $` t_{TT} `$. За $` ts \left \lparen o \right \rparen `$ можно взять $e$ или $l$. $e$ не подходит, поскольку возможно, что $` t_1 \prec_{rt} e `$. По этой же логике не подходит ни одна другая точка внутри интервала. Остаётся $l$, для которого $` t_1 \le t_{TT} \le l `$. Для этого нужно выполнить **Commit Wait** (`Spanner`) - гарантированно дождаться наступления $l$. Нельзя делать $` SleepFor \left \lparen l - e \right \rparen `$ из-за drift-а. Нужно спать в цикле, дожидаясь $` l \le TT.Now \left \lparen \right \rparen .e `$, после чего продолжить выполнять операцию и начать собирать кворум

В действительности можно сначала собрать кворум, после чего выполнить Commit Wait, поскольку ответ клиенту нужно дать после обоих действий. Лишь после получения ответа, операция завершится и можно будет начать следующую в $rt$ порядке

Такой алгоритм имеет смысл лишь в геораспределённых системах, поскольку в пределах одного датацентра быстрее сходить по сети

TODO: В такой схеме снова нарушается линеаризуемость упорядоченных чтений, как описано в [лекции 2](https://github.com/ddvamp/distributed-db-learning/blob/main/notes/dist-sys-mipt/lectures/lecture-2.md#нарушение-линеаризации). Как это исправить? Нет ли других проблем?

#### Snapshot в LSM

Займёмся оптимизацией кода локального хранилища на примере операции $` Update \left \lparen k, v, ts \right \rparen `$ - если у ключа $k$ метка меньше, чем $ts$, записать в него $v$. Последовательные чтение, сравнение и запись не атомарны. Наивное решение - mutex, что крайне неэффективно, поскольку мы сериализуем доступ к независимым ключам, а система теряет конкурентность. Чуть лучше - шардировать mutex по ключам, например, по остатку от деления на 128, но всё равно с последовательными записями в шардах

TODO: Сама постановка проблемы подразумевает, что реализация LSM должна поддерживать конкурентные операции. Какие именно и как это должно быть реализовано?

**Snapshot** - иммутабельный снимок текущего состояния распределённой системы, который не меняется от последующих изменений в системе. Используя его, можно итерироваться по хранилищу в этом состоянии. Будем строить его для некоторых операций

Интерфейс LSM (`LevelDB`)
- Put $` \left \lparen k, v \right \rparen `$
- Delete $` \left \lparen k \right \rparen `$
- Get $` \left \lparen k \right \rparen `$
- Snapshot $` \left \lparen \right \rparen `$
- batch-и операций (атомарное применение)

LSM состоит из Log + SSTable + MemTable, где SSTable - иммутабельное хранилище большей части ($` \sim 90 \%`$) данных, что очень подходит для снимков. Сделаем хранилище **мультиверсионным**, добавив к ключу $s$ - **Sequence Number** как его часть. Sequence Number глобальный на всё хранилище и инкрементируется при каждой операции $Put$ (в случае batch-а увеличивается на его размер). Взять Snapshot означает запомнить текущий Sequence Number. $` Put \left \lparen k, v \right \rparen \to \widetilde{Put} \left \lparen \left \lparen k, s_{next} \right \rparen , v \right \rparen `$, и MemTable отсортирован по $` \left \lparen k, s \right \rparen `$. $` Get \left \lparen k \right \rparen \to \widetilde{Get} \left \lparen k, s = current \left \lparen \right \rparen \right \rparen `$ начинает принимать Sequence Number вторым аргументом

Впоследствии снимки пригодятся для реализации транзакций

TODO: Как используя снимок можно реализовать $Update$ и batch?

[↑ Содержание ↑](https://github.com/ddvamp/distributed-db-learning/tree/main/notes/dist-sys-mipt#содержание)\
[← Лекция 6](https://github.com/ddvamp/distributed-db-learning/blob/main/notes/dist-sys-mipt/lectures/lecture-6.md)
[Лекция 7 →](https://github.com/ddvamp/distributed-db-learning/blob/main/notes/dist-sys-mipt/lectures/lecture-7.md)
