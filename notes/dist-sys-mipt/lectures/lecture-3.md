## Lecture 3. Atomic Broadcast, State Machine Replication, Consensus

#### Репликация регистра = репликация множества

Полезное свойство линеаризуемости состоит в том, что история взаимодействия с двумя линеаризуемыми объектами в совокупности также является линеаризуемой, в отличие от, например, *SC*. Благодаря ему мы и можем свести задачу репликации многих значений к репликации регистра, а далее произвести обратный переход

#### ABD и CAS

Построенный в лекции 2 алгоритм называется **ABD (Attiya, Bar-Noy, Dolev)**, и его недостаточно для наших целей
- read/write мало для транзакций
- он не предусматривает реконфигурации

В действительности он достаточен для некоторых систем

Хотим операцию $CAS \left \lparen expected, desired \right \rparen : bool$. Для согласования значения разрозненных реплик мы использовали $ts$ для линеаризации. С ними запоздавшую запись легко встроить в глобальную историю - просто отбросить её, будто она была раньше и уже перетёрта. Аналогичный подход не работает с CAS. Рассмотрим сценарий $x \overset{CAS_{t_2} \left \lparen y, z \right \rparen}{\longrightarrow} x  \overset{CAS_{t_1} \left \lparen x, y \right \rparen}{\longrightarrow} y$. В нём из-за запоздавшей операции вместо $z$ получили $y$, т.е. порядки $rt$ и $ts$ отличаются. Откладывать пришедшие CAS-ы и выстраивать их по $ts$ не выйдет, поскольку $ts$ не строго монотонные, т.е. нельзя понять, сколько ещё нужно дождаться CAS-ов до применения отложенного

Таким образом, порядок $ts$, задающий порядок применения операций, не соответствует произвольному порядку получения операций репликами, и неясно, когда команда готова к применению. Необходим механизм транспорта команд в одинаковом для всех узлов порядке, который и будет порядком применения. Придумаем более удобную абстракцию без $ts$ и с произвольными операциями

#### Totally Ordered Broadcast

**Totally Ordered Broadcast (Atomic Broadcast)** - примитив/протокол синхронизации или транспорт команд для решения задачи репликации. Имеет единственную операцию $A-BCast \left \lparen m \right \rparen $ - посредством некоторого распределённого алгоритма доставить *всем* узлам, в том числе себе, сообщение $m$, после получения которого на каждом узле eventually сработает обработчик $A-Deliver \left \lparen m \right \rparen $. Хотим, чтобы при рассылке каждый несбойный узел получил сообщение, и чтобы на каждом узле обработчики вызывались в одинаковом порядке, независимо от порядка отправки. Порядок обработки и будет заменой $ts$. При этом операцию может стартовать любой узел

Формально хотим три свойства
- **Validity** - если несбойный узел стартовал $AB$, то eventually на этом узле сработает $AD$
- **Agreement** - если несбойный узел стартовал $AB$, то eventually на остальных несбойных узлах сработает $AD$
- **Total Order** - есть общий порядок обработки. Физически сообщения могут доставляться в разном порядке, но со временем на каждом узле будет формироваться одинаковый префикс логически доставленных, т.е. обработанных сообщений. Должно выполняться и для сбойных узлов
- **(Integrity)** - сообщения не возникают из воздуха и доставляются ровно один раз. Простое свойство, которое опускаем

Несбойность означает, что если узел бесконечно долго работает без отказа, то он не может бесконечно долго не обрабатывать сообщение, eventually это произойдёт - liveness. Т.о., первые два свойства говорят, что каждое отправленное сообщение будет обработано, и что несбойные узлы обработают одинаковый набор сообщений, а третье, что порядок обработки этих сообщений будет единым

#### Replicated State Machine

Рассмотрим использование Atomic Broadcast в задаче **репликации произвольного автомата (State Machine Replication)**. Имеем реплицированный объект $s$ с единственной мета-операцией $s.Apply \left \lparen cmd \right \rparen \to \left \lparen s', r \right \rparen $, которая применяет к объекту произвольную команду $cmd$ с неизвестной семантикой, переводя его в новое состояние, и что-то возвращает. Реплики хранят копию объекта в начальном состоянии. Очередная команда $c$ попадает на некоторый узел, который становится координатором и инициирует $A-BCast \left \lparen c \right \rparen $. Eventually на каждом узле, внутри обработчика $A-Deliver \left \lparen c \right \rparen $ происходит вызов $s.Apply \left \lparen c \right \rparen $. Когда это случится на координаторе, он (сразу) возвращает результат клиенту, и операция считается завершённой. Благодаря Atomic Broadcast изменения на всех репликах согласованы

Получили **Replicated State Machine (RSM)** - отказоустойчивый распределённый автомат, который снаружи выглядит как один узел, применяющий операции в порядке AB. RSM активно применяется в проде (например в `YDB` система вместо ненадёжных узлов состоит из одних RSM - *Tablets*, название пошло из `BigTable`). Это высокоуровневая схема репликации, сложности сокрыты в реализации AB

В описанном RSM координатор может вернуть результат раньше, чем любой другой узел увидит рассылку. В действительности такое невозможно, поскольку в реализации Atomic Broadcast будет использоваться алгоритм кворумов

#### Докозательство линеаризуемости

Линеаризуемость: необходимо линеаризовать любое исполнение (историю), и поскольку имеем TO, единый для всех узлов, выберем линеаризацией его. Линеаризация что-то требует от упорядоченных событий. Значит необходимо показать, что если два события упорядочены во времени, то они стоят в таком же порядке в TO (и тогда ТО действительно можно взять за линеаризацию)
Доказательство от противного. Пусть две операции упорядочены во времени, то есть результат первой операции стал виден клиенту до инициации второй. И пусть на некоторой реплике вторая операция завершилась раньше первой. Тогда такое должно произойти на всех репликах, а значит и на координаторе первой операции. Но из этого следует, что вторая операция завершилась во времени раньше, чем первая, а значит раньше, чем сама началась. Противоречие

В действительности одного AB для написания RSM мало. Ограничения
1. Детерменированность мета-операции s.Apply(c) -> (s', r), то есть результат операции должен быть одним и тем же при неизменных входных данных. В противном случае состояния автомата могут разойтись на разных репликах. Убираем случайные величины: рандом, время (часы), операции с плавающей точкой (зависят на процессора), хэш таблицы (сид/соль может быть на основе адреса + ASLR). Так же нельзя при замене отказавшего узла менять код RSM на новом узле
2. Нельзя ретраить операцию по таймауту, поскольку неясно, завершилась она или нет (реплика может взорваться как перед подтверждением, так и сразу после получения запроса, а может она просто подвисла и ретрай попадёт на другую реплику), и если она выполнилась и не является идемпотентной, получим mess. Это At-Least-Once семантика. Необходима Exactly-Once семантика, которую должен обеспечить клиент (RSM не способен)
3. RSM реплицирует лишь состояние, помещающееся в одну машину, но для больших объёмов данных необходимо заводить несколько RSM, которые не обладают сквозным (общим) TO (Прим: range в KV Store являются RSM). Мы не можем "атомарно" поменять диапазон ключей, попавших в несколько range-ей. Проблема решается распределёнными Транзакциями (шардирование данных)
4. Быстрые read-only операции в наивной реализации (без прохода через AB) не будут линеаризуемыми, поскольку можно прочесть из реплики, на которой применённая операция ещё не записана, или наоборот

Реализация AB состоит из двух независимых задач:
- Reliable Broadcast (Validity + Agreement) - гарантированная доставка сообщения всем узлам в произвольном порядке
- Consensus (TO) - согласование узлами общего порядка

Reliable Broadcast (R-BCast(m))
Нельзя отправлять всем сообщение поочерёдно; если в процессе узел умрёт, то не все узлы сообщение получат, и нарушатся свойства AB. Пусть узел при получении сообщения в первый раз ретрансмитит его всем другим узлам. Так невозможно, что какой-то несбойный узел не получит сообщение, если другой несбойный его получил (это теоретический трюк, в реальности по другому, например протокол Gossip)

Consensus
Пусть есть три узла, и каждому из них на вход дают независимое значение Vi. Каждый узел должен реализовать синхронный алгоритм Propose(Vi) -> V*: все предлагают своё значение Vi и из них выбирают одно общее V*. Свойства (гарантии) алгоритма:
- Validity - V* одно из предложенных Vi
- Agreement - все узлы получат один и тот же V*
- Termination - алгоритм должен завершаться
Также хотим отказоустойчивость. Пример неотказоустойчивого решения: предопределяем главный узел, отправляем ему все значения, он выбирает первое. Если же доставка значения на главный узел осуществляется через AB, то консенсус решён
На самом деле Consensus ~ AB, ведь консенсус является одним шагом бесконечной задачи AB

Выразим AB через Consensus (обратное тоже возможно)
Положим Consensus умеем решать и имеем R-BCast. Для TO необходима серия консенсусов C1 -> C2 -> C3, очередной Cn выбирает сообщение/пачку сообщений Bn, которое нужно доставить всем
Координатор выполняет A-BCast(m), который рассылает сообщения - выполняет R-BCast(m). При получении сообщения каждый узел запускает обработчик R-Deliver(m), который помещает сообщение в своё личное множество Ri известных сообщений, изначально пустое. Их предстоит упорядочить, вызвать A-Deliver и поместить в Ai - множество уже обработанных сообщений, также личное. Со временем все Ai будут наполняться одинаково
Для обработки Ri на каждом узле запущен фоновый процесс, работающий по раундам. Начинаем с r <- 0. Пока есть сообщения в Ri, которых нет в Ai (Ri - Ai != 0) (полагаем, что сообщения только добавляются в Ri и Ai), начинаем новый раунд r <- r + 1 и инициируем консенсус, предлагая все такие сообщения B^r <- Propose(r, Ri - Ai = Bi^r). Для упорядоченного результата B^r вызываем обработчик A-Deliver(B^r) (внешний обработчик), после чего добавляем его во множество обработанных Ai <- Ai u B^r (на практике обработанные сообщения убирают из Ri). Поскольку алгоритм консенсуса является синхронным, раунды проходят строго последовательно
Напоминание: в контексте RSM Ri это всё сообщения об операциях над одной ячейкой (состоянием)

A-BCast(m) => R-BCast(m) => R-Deliver(m) => Ri <- Ri u {m}

r <- 0
while Ri - Ai != 0
  r <- r + 1
  B^r <- Propose(r, Bi^r <- Ri - Ai)
  A-Deliver(B^r)
  Ai <- Ai u B^r

Так на узел могут приходить сообщения, которые уже выбрали консенсусом. Они просто проигнорируются
Нельзя предлагать на консенсус одно/мало сообщений, поскольку оно может бесконечно долго проигрывать более новым сообщениям и никогда не быть доставленым (голодание сообщения, клиент ждёт подтверждения). Альтернатива: предлагать самое старое сообщение, тогда в какой-то момент его предложат все узлы вместе (по гарантии eventualy доставки на реплику)

В итоге свели RSM к AB, а его к задаче консенсуса, и сколько отказов способна переживать реализация Consensus, столько же отказов сможет переживать RSM

В реальности RSM не строят через AB, который строят через Consensus как из отдельных компонентов. Реализуют единый алгоритм репликации на этих основах

[↑ Содержание ↑](https://github.com/ddvamp/distributed-db-learning/tree/main/notes/dist-sys-mipt#содержание)\
[← Семинар 2](https://github.com/ddvamp/distributed-db-learning/blob/main/notes/dist-sys-mipt/seminars/seminar-2.md)
[Семинар 3 →](https://github.com/ddvamp/distributed-db-learning/blob/main/notes/dist-sys-mipt/seminars/seminar-3.md)
