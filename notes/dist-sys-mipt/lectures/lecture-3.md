## Lecture 3. Atomic Broadcast, State Machine Replication, Consensus

Полезное свойство линеаризуемости: история взаимодействия с двумя линеаризуемыми объектами в совокупности также является линеаризуемой (в SC это не так)

Построенный алгоритм называется ABD (Attiya, Bar-Noy, Dolev), и его недостаточно
- read/write мало для транзакций
- не предусматривает переконфигурации
Хотим добавить в него CAS(exp, dis): bool. Наивные размышления приводят в тупик. Запоздавшую запись легко встроить в согласованную с timestamp-ами глобальную историю - просто отбросить её, будто она была раньше, а после перетёрта. Аналогичный подход с CAS не работает, возможна ситуация init = x -> CAS(y, z, t2) -> CAS(x, y, t1), где получим y, хотя должны z. Результат зависит от порядка прихода сообщений, однако по timestamp-ам должен быть один. Хранить CAS-ы и выстраивать их по timestamp-ам не выйдет, поскольку в реальности не используются строго монотонные ts (нельзя понять, сколько ещё timestamp-ов идёт перед произвольным)
Отметим, что в реальности в частных случаях алгоритм ABD является достаточным для некоторых систем

Суть проблемы: операции (их применение) упорядочены через timestamp-ы, но на реплику приходят в произвольном порядке, и неясно, когда команда готова к применению (она первая из неприменённых). Необходим механизм транспорта команд в одинаковом для всех узлов порядке, который и будет порядком применения команд
Цель: отказаться от timestamp-ов, а после научиться выполнять произвольные операции на репликах

Totally Ordered Broadcast (Atomic Broadcast) - примитив синхронизации для задачи репликации, умеющий в CAS. Его единственная операция A-BCast(m) - отправить всем узлам (себе тоже) сообщение m через некоторый алгоритм (не буквально сообщение в сеть), при получении которого узел вызывает обработчик A-Deliver(m). И хотим, чтобы сообщение было доставлено на каждый несбойный узел, и на каждом узле все сообщения обрабатывались в одном порядке, независимо от порядка их отправки. Порядок обработки и есть замена timestamp-ам
Формально хотим три свойства:
- Validity - если несбойный узел стартовал AB, то eventually на самом узле сработает AD
- Agreement - если несбойный узел стартовал AB, то eventually на всех других несбойных узлах сработает AD
- Integrity - сообщения не возникают из воздуха и доставляются ровно один раз. Простое свойство, которое опускаем
- Total Order - есть общий порядок доставки. Т.е. со временем на каждом узле будет формироваться одинаковый префикс пришедших сообщений. Должно выполняться и для сбойных узлов. Как именно гарантируется порядок неясно - это абстракция
Несбойность означает, что если бесконечно долго на узле нет отказа, то он не может бесконечно долго сообщение не получать; eventually оно будет доставлено (возможно на умерший узел) - liveness
Первые два - все узлы получат одинаковый набор сообщений, последнее - порядок этих сообщений будет единым. Т.е. если узел первым получил некоторое сообщение, остальные несбойные узлы гарантированно тоже его получат
Этот примитив будет транспортом команд между репликами

Мотивируем изучение A-BCast, использовав его для репликации произвольного автомата (State Machine Replication)
Имеем объект с единственной мета-операцией Apply(cmd). Она переводит объект в новое состояние и что-то возвращает: s.Apply(c) -> (s', r). Семантика мета-операции неизвестна. Объект реплицирован в начальном состоянии. Red клиент отправил Red команду c1, она попала на некоторую реплику, которая стала Red координатором и стартовала A-BCast(c1). При получении сообщения каждый узел в обработчике A-Deliver(c1) выполняет s.Apply(c1), в том числе координатор, который возвращает результат выполнения операции клиенту, и команда считается завершённой. Узлы ничего не отвечают координатору. Теперь появился Blue клиент с Blue командой c2, попавшей на Blue координатор, отличный от Red, выполняющий то же самое
Благодаря atomic broadcast изменения на всех репликах объекта согласованы. Получили Replicated State Machine (RSM) - отказоустойчивый распределённый автомат, который снаружи выглядит как один узел, применяющий операции (переходы) в порядке AB. RSM активно применяется в проде (например в YDB всё RSM - Tablets, название пошло из BigTable). Это высокоуровневая схема репликации, сложности сокрыты в реализации AB

Промежуточный итог: мы выдумали Atomic Broadcast, примитив, который хотелось бы/разумно иметь, и если этот примитив коммуникации реализовать, то используя его для транспорта команд получится реплицировать произвольные объекты, например SM, получая RSM, который по сути является реплицированной ячейкой с произвольной операцией над ней. RSM является аналогом разделяемой ячейки памяти, поскольку клиент может придти с операцией на любую реплику, модифицировать RSM, думая что она локальная, а RSM через AB-Cast пошлём всем репликам команду обновления, которые имеют TO

Уточнение: нас не беспокоит, что в такой абстракции координатор может послать сообщение раньше, чем оно достигнет остальные узлы, поскольку в реализации, разумеется, используется алгоритм кворумов, и такое невозможно

Линеаризуемость: необходимо линеаризовать любое исполнение (историю), и поскольку имеем TO, единый для всех узлов, выберем линеаризацией его. Линеаризация что-то требует от упорядоченных событий. Значит необходимо показать, что если два события упорядочены во времени, то они стоят в таком же порядке в TO (и тогда ТО действительно можно взять за линеаризацию)
Доказательство от противного. Пусть две операции упорядочены во времени, то есть результат первой операции стал виден клиенту до инициации второй. И пусть на некоторой реплике вторая операция завершилась раньше первой. Тогда такое должно произойти на всех репликах, а значит и на координаторе первой операции. Но из этого следует, что вторая операция завершилась во времени раньше, чем первая, а значит раньше, чем сама началась. Противоречие

В действительности одного AB для написания RSM мало. Ограничения
1. Детерменированность мета-операции s.Apply(c) -> (s', r), то есть результат операции должен быть одним и тем же при неизменных входных данных. В противном случае состояния автомата могут разойтись на разных репликах. Убираем случайные величины: рандом, время (часы), операции с плавающей точкой (зависят на процессора), хэш таблицы (сид/соль может быть на основе адреса + ASLR). Так же нельзя при замене отказавшего узла менять код RSM на новом узле
2. Нельзя ретраить операцию по таймауту, поскольку неясно, завершилась она или нет (реплика может взорваться как перед подтверждением, так и сразу после получения запроса, а может она просто подвисла и ретрай попадёт на другую реплику), и если она выполнилась и не является идемпотентной, получим mess. Это At-Least-Once семантика. Необходима Exactly-Once семантика, которую должен обеспечить клиент (RSM не способен)
3. RSM реплицирует лишь состояние, помещающееся в одну машину, но для больших объёмов данных необходимо заводить несколько RSM, которые не обладают сквозным (общим) TO (Прим: range в KV Store являются RSM). Мы не можем "атомарно" поменять диапазон ключей, попавших в несколько range-ей. Проблема решается распределёнными Транзакциями (шардирование данных)
4. Быстрые read-only операции в наивной реализации (без прохода через AB) не будут линеаризуемыми, поскольку можно прочесть из реплики, на которой применённая операция ещё не записана, или наоборот

Реализация AB состоит из двух независимых задач:
- Reliable Broadcast (Validity + Agreement) - гарантированная доставка сообщения всем узлам в произвольном порядке
- Consensus (TO) - согласование узлами общего порядка

Reliable Broadcast (R-BCast(m))
Нельзя отправлять всем сообщение поочерёдно; если в процессе узел умрёт, то не все узлы сообщение получат, и нарушатся свойства AB. Пусть узел при получении сообщения в первый раз ретрансмитит его всем другим узлам. Так невозможно, что какой-то несбойный узел не получит сообщение, если другой несбойный его получил (это теоретический трюк, в реальности по другому, например протокол Gossip)

Consensus
Пусть есть три узла, и каждому из них на вход дают независимое значение Vi. Каждый узел должен реализовать синхронный алгоритм Propose(Vi) -> V*: все предлагают своё значение Vi и из них выбирают одно общее V*. Свойства (гарантии) алгоритма:
- Validity - V* одно из предложенных Vi
- Agreement - все узлы получат один и тот же V*
- Termination - алгоритм должен завершаться
Также хотим отказоустойчивость. Пример неотказоустойчивого решения: предопределяем главный узел, отправляем ему все значения, он выбирает первое. Если же доставка значения на главный узел осуществляется через AB, то консенсус решён
На самом деле Consensus ~ AB, ведь консенсус является одним шагом бесконечной задачи AB

Выразим AB через Consensus (обратное тоже возможно)
Положим Consensus умеем решать и имеем R-BCast. Для TO необходима серия консенсусов C1 -> C2 -> C3, очередной Cn выбирает сообщение/пачку сообщений Bn, которое нужно доставить всем
Координатор выполняет A-BCast(m), который рассылает сообщения - выполняет R-BCast(m). При получении сообщения каждый узел запускает обработчик R-Deliver(m), который помещает сообщение в своё личное множество Ri известных сообщений, изначально пустое. Их предстоит упорядочить, вызвать A-Deliver и поместить в Ai - множество уже обработанных сообщений, также личное. Со временем все Ai будут наполняться одинаково
Для обработки Ri на каждом узле запущен фоновый процесс, работающий по раундам. Начинаем с r <- 0. Пока есть сообщения в Ri, которых нет в Ai (Ri - Ai != 0) (полагаем, что сообщения только добавляются в Ri и Ai), начинаем новый раунд r <- r + 1 и инициируем консенсус, предлагая все такие сообщения B^r <- Propose(r, Ri - Ai = Bi^r). Для упорядоченного результата B^r вызываем обработчик A-Deliver(B^r) (внешний обработчик), после чего добавляем его во множество обработанных Ai <- Ai u B^r (на практике обработанные сообщения убирают из Ri). Поскольку алгоритм консенсуса является синхронным, раунды проходят строго последовательно
Напоминание: в контексте RSM Ri это всё сообщения об операциях над одной ячейкой (состоянием)

A-BCast(m) => R-BCast(m) => R-Deliver(m) => Ri <- Ri u {m}

r <- 0
while Ri - Ai != 0
  r <- r + 1
  B^r <- Propose(r, Bi^r <- Ri - Ai)
  A-Deliver(B^r)
  Ai <- Ai u B^r

Так на узел могут приходить сообщения, которые уже выбрали консенсусом. Они просто проигнорируются
Нельзя предлагать на консенсус одно/мало сообщений, поскольку оно может бесконечно долго проигрывать более новым сообщениям и никогда не быть доставленым (голодание сообщения, клиент ждёт подтверждения). Альтернатива: предлагать самое старое сообщение, тогда в какой-то момент его предложат все узлы вместе (по гарантии eventualy доставки на реплику)

В итоге свели RSM к AB, а его к задаче консенсуса, и сколько отказов способна переживать реализация Consensus, столько же отказов сможет переживать RSM

В реальности RSM не строят через AB, который строят через Consensus как из отдельных компонентов. Реализуют единый алгоритм репликации на этих основах

[↑ Содержание ↑](https://github.com/ddvamp/distributed-db-learning/tree/main/notes/dist-sys-mipt#содержание)\
[← Семинар 2](https://github.com/ddvamp/distributed-db-learning/blob/main/notes/dist-sys-mipt/seminars/seminar-2.md)
[Семинар 3 →](https://github.com/ddvamp/distributed-db-learning/blob/main/notes/dist-sys-mipt/seminars/seminar-3.md)
