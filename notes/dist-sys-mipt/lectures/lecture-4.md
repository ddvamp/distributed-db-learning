## Lecture 4. Невозможность консенсуса, теорема FLP

Рассмотрим два ограничения алгоритма консенсуса, на *количество отказов* и *возможность его завершения*

#### Отказоустойчивость задачи Consensus

Алгоритм ABD способен пережить $` f \lt \left \lceil \frac{n}{2} \right \rceil `$ отказов, после чего не собрать кворум. Можно ли лучше? Посмотрим, сколько отказов способен пережить Consensus

Имеем произвольное количество узлов. Рассмотрим на них три различных исполнения $` E_0, \hspace{0.25em} E_{0/1}, \hspace{0.25em} E_1 `$. В $E_0$ все узлы предлагают на консенсус $0$, в $E_1$ предлагают $1$, а в $E_{0/1}$ произошёл произвольный partition на части $A$ и $B$ такие, что в $A$ все узлы предлагают $0$, а в $B$ предлагают $1$. И пусть в $E_0$ отказали все узлы, соответствующие части $B$, в $E_1$ соответствующие части $A$, а в $E_{0/1}$ отказов нет

Возмём произвольный корректный алгоритм консенсуса и посмотрим на его возможные поведения. Если он собирается завершиться, то по нему в $E_0$ выберут $0$, а в $E_1$ выберут $1$. В $E_{0/1}$ части $A$ и $B$ не видят отличий от исполнений $E_0$ и $E_1$, а значит в них при завершении алгоритма узлы выберут $0$ и $1$ соответственно. Здесь нет нарушений со стороны Reliable Broadcast, поскольку eventually сеть восстановится, и сообщения доставятся

Выбор узлов отличается, а значит мы потеряли Agreement, TO нарушился, значения реплик RSM разошлись. Это означает, что в случае любого partition корректный алгоритм консенсуса должен заблокироваться (потерять Termination) как минимум в одной из частей, и для отказоустойчивости оптимальнее в меньшей. Минимальный размер большей части по всем разбиениям это majority. Если представить, что partition это отказ узлов, становится ясно, что корректный алгоритм консенсуса способен пережить не более половины отказов. В противном случае оставшиеся узлы не смогут отличить отказ других узлов от partition, и произойдёт Split Brain

Алгоритму не нужно знать о наличии partition или число отказов. Он продолжает работать, покуда в связной части системы собираются кворумы. И это имеет смысл, ведь partition возможен одновременно с отказами и другими partition

#### Теорема FLP

**Теорема FLP (Fischer, Lynch, Paterson, 85).** В Asynchronous Model даже в случае одного отказа никакой корректный детерменированный алгоритм консенсуса не способен гарантировать Termination во всех исполнениях

Доказательство. Представим произвольный алгоритм консенсуса в виде графа его всевозможных исполнений. Узлами графа являются **Configuration (nodes + network)** - мгновенный снимок состояния мира (содержимое памяти, дисков, регистров, RIP, ядер, проводов и бегущих по ним сообщений). Исполнение алгоритма характеризуется переходами между конфигурациями

Пусть у конфигурации $C$ в сети есть сообщение $m$ для узла $` p: \hspace{0.5em} \left \lparen m, p \right \rparen \in Net \left \lparen C \right \rparen `$, тогда в графе существует переход $` C \to C^{'} `$ означающий, что $m$ дошло раньше остальных сообщений, а $C^{'}$ - конфигурация мира после всех реакций узла $p$ на $m$ (изменение состояния, отправка других сообщений и пр.). Количество переходов из конфигурации соответствует числу сообщений в её сети. Для целей доказательства считаем переходы мгновенными, что в действительности не так

Есть начальные конфигурации, по одной на каждый набор входных значений. Путь в графе отражает некоторое исполнение. Берём на себя роль *Adversary* и сами строим путь, однако как честный Adversary мы обязаны eventually доставить каждое отправленное сообщение. Отказ узла означает, что с некоторого момента пути можно игнорировать связанные с отказавшим узлом переходы. Теорема утверждает, что мы можем построить бесконечный путь

Будем доказывать для *бинарного консенсуса*: $` v_{in} \in \{0,1\} `$. Есть два вида конфигурации
- **бивалентная** - конфигурация без предопределённого выбора, где в зависимости от дальнейшего пути могут выбрать как $0$, так и $1$
- **унивалентная** - конфигурация с предопределённым выбором, который не зависит от дальнейшего пути
  - $0-val$ - выберут $0$
  - $1-val$ - выберут $1$

Необходимо показать, что мы можем бесконечно ходить по бивалентным конфигурациям

**Лемма 1.** Какой бы алгоритм консенсуса мы не взяли, существует такой набор входных значений, для которого алгоритм консенсуса не знает заранее что он выберет

От противного. Пусть все начальные конфигурации univalent. Рассмотрим цепочку начальных конфигураций $` C_0 = \begin{pmatrix} 0\\ 0\\ \vdots \\ 0 \end{pmatrix}, \hspace{0.25em} C_1 = \begin{pmatrix} 1\\ 0\\ \vdots \\ 0 \end{pmatrix}, \dots, C_n = \begin{pmatrix} 1\\ 1\\ \vdots \\ 1 \end{pmatrix} `$. В $C_0$ выберут $0$, в $C_n$ выберут $1$, в $C_i$ выберут $0$ или $1$. Очевидно, что в цепочке найдётся пара $` \left \lparen C_{k-1}, C_k \right \rparen `$ такая, что в $` C_{k-1} `$ выберут $0$, а в $C_k$ выберут $1$. Они отличаются только значением на входе узла $k$, при смерти которого алгоритм каким-то образом должен отличить два исполнения, что невозможно. Значит должна существовать начальная бивалентная конфигурация

**Лемма 2.** Из бивалентной конфигурации всегда можно перейти в бивалентную конфигурацию

Пусть $C$ текущая bivalent конфигурация. Рассмотрим в ней произвольное сообщение $` \left \lparen m, p \right \rparen \in Net \left \lparen C \right \rparen `$, для которого $e$ - событие доставки $m$, $S$ - бесконечное множество достижимых из корня $C$ конфигураций без доставки $m$, $S_e$ - множество конфигураций, достижимых из $S$ одним переходом по событию $e$. Узел $p$ убивать не собираемся, значит любое исполнение eventually пройдёт через одну из конфигураций $S_e$. Согласно лемме в $S_e$ существует бивалентная конфигурация $C_e$

От противного. Пусть в $S_e$ любая конфигурация univalent

*Шаг 1.* В $S_e$ найдётся хотя бы по одной $0-val$ и $1-val$ конфигурации. Допустим, все конфигурации в $S_e$ $0-val$. Поскольку мы обязаны попасть в $S_e$, и на любом пути алгоритм неизбежно выберет $0$, $C$ - univalent. Противоречие

*Шаг 2.* В $S$ найдётся пара конфигураций $C^{'}$ и $C^{''}$ таких, что событие $e^{'}$ - доставка $` \left \lparen m^{'} , p^{'} \right \rparen \in Net \left \lparen C^{'} \right \rparen `$ - это переход $C^{'} \to C^{''}$, а событие $e$ переход $C^{'} \to 0-val$ и $C^{''} \to 1-val$. Допустим, таких $C^{'}$ и $C^{''}$ нет, тогда на любом пути из $C^{'}$ каждая последующая конфигурация из $S$ будет также попадать в $0-val$ конфигурацию из $S_e$. Но тогда там все конфигурации $0-val$. Противоречие с шагом 1

*Шаг 3.* Предположим, что $p^{'} \not = p$. Тогда события $e$ и $e^{'}$ и их протекания независимы, а значит результаты последовательностей $ee^{'}$ и $e^{'} e$ должны быть одинаковы. Последовательность событий $e^{'} e$ приводит в $1-val$ конфигурацию, однако событие $e$ приводит в $0-val$ конфигурацию, а значит при $ee^{'}$ должен выполняться переход $0-val \to 1-val$, что невозможно. Значит $p^{'} = p$. Виртуально убъём узел $p$, задержав от и для него все текущие и последующие сообщения, но даже тогда алгоритм по постановке собирается завершиться. Значит из $C^{'}$ существует некоторый конечный суффикс пути. Допустим, он оканчивается в $1-val$. Приложим этот же суффикс к $0-val$ и $1-val$ конфигурациям из шага $2$, также виртуально убив $p$. Поскольку для всех узлов кроме $p$ разницы нет, оба пути должны прийти к $1-val$. Но тогда на суффиксе, приложенном к $C^{''}$, должен произойти переход $0-val \to 1-val$, что, снова, невозможно. (Суффикс взяли из $C^{'}$, а не одной из univalent конфигураций, потому как первая заведомо существует)

Суммируя, по лемме 2, если в $S_e$ нет бивалентных конфигураций, то
1. в $S_e$ найдётся и $0-val$, и $1-val$
2. в $S$ найдётся $C^{''}$, переход к которой меняет итоговую валентность
3. и должен найтись путь через $C^{''}$, на котором меняется предопределённая валентность, что невозможно

Противоречие, значит в $S_e$ найдётся бивалентная конфигурация

Таким образом, если (по лемме 1) начать в бивалентной конфигурации, то (по лемме 2) можно бесконечно выбирать самое старое сообщение, ведущее в бивалентную конфигурацию, и получить livelock. Теорема говорит, что даже если в системе нет отказов, но возможны, консенсус может завершаться сколь угодно долго, потому что в асинхронной модели система не может отличить сбойный узел от медленного

#### Моё доказательство FLP

Я не понимаю, как применяется лемма 2, поэтому привожу своё доказательство

**Лемма 1.** Найдётся начальная bivalent конфигурация

Доказательство аналогично оригинальной лемме 1

**Лемма 2.** Для любой bivalent конфигурации найдётся переход в bivalent конфигурацию

От противного. Пусть в некоторой bivalent конфигурации все переходы ведут к univalent конфигурациям (**патовая ситуация**). Пусть найдётся пара переходов к конфигурациям разной валентности. Эти два перехода могут быть связаны с доставкой сообщений разным узлам или одному. Как и в оригинальной лемме 2, оба варианта невозможны (из-за порядка независимых переходов и из-за разных итоговых валентностей в одном и том же суффиксе). Значит все переходы ведут к конфигурациям одной валентности, что снова невозможно в силу бивалентности исходной конфигурации

**Лемма 3.** При бесконечном блуждании по bivalent конфигурациям для произвольного бесконечно долго недоставляемого сообщения будут бесконечно появляться переходы в bivalent конфигурации

Используя доказательство оригинальной леммы 2, показываем, что найдётся хотя бы один такой переход. Если для конфигурации он единственный переход в bivalent конфигурацию, просто доставляем сообщение. Иначе пропускаем, и гарантированно будет следующий по индукции

Таким образом, можно начать в bivalent конфигурации (по лемме 1) и бесконечно блуждать по bivalent конфигурациям (по лемме 2), при этом eventually доставляя каждое сообщение (по лемме 3). Лемма 2 говорит, что в каждой bivalent конфигурации есть как минимум один переход в bivalent конфигурацию, т.е. что мы не можем попасть в патовую ситуацию. Если их несколько, всегда выбираем связанный с наиболее старым сообщением. Лемма 3 говорит, что сценарий, где все переходы в bivalent конфигурацию формируются лишь новыми сообщениями не является единственно возможным, т.е. что каждое конкретное сообщение, в том числе самое старое, всегда можно eventually доставить не завершая алгоритм

Более того, согласно лемме 2 невозможно, что в произвольной bivalent конфигурации есть два сообщения, которые, будь каждое из них доставлено следующим, предопределяют разные результаты алгоритма. Либо некоторые сообщения все предопределяют один и тот же результат, либо алгоритм продолжит работу

#### Итог

Теорема о partition говорит, что при majority отказов теряется Agreement. Мы обязаны не завершиться. Нет safity $` \sim `$ deadlock. Теорема FLP говорит, что, если возможны сбои, теряется Termination. Мы можем не завершиться. Нет liveness $` \sim `$ livelock

Если система использует алгоритм консенсуса, у неё есть периоды недоступности, на которые никак не повлиять. Удобно и полезно при построении алгоритма консенсуса или просматривая чужой искать livelock, при отсутствии которого алгоритм некорректен

#### Как преодолеть FLP

Чтобы гарантировать Termination, необходимо перейти в частично синхронную модель с предположениями о времени. Суть проблемы в том, что алгоритм консенсуса не способен отличить сбойный узел от медленного. В частично синхронной модели существуют периоды времени, которые помогают алгоритму завершиться. Именно поэтому нужны таймауты, таймеры, периодические Heartbeat-ы. Это не математическое решение, но инженерное

Время (таймауты) нужно чтобы определять сбои. Можно свести Consensus $\to$ *Failure Detector (задача построения детектора сбоев)*, и думать не в каких предположениях о времени решается консенсус, а в каких предположениях о времени строится детектор сбоев, и какие от него гарантии нужны для консенсуса

**Failure Detector** - компонент, который находится на каждом узле и умеет отвечать, возможно, ошибочно, на вопрос о том, жив ли какой-то другой узел. По FLP его невозможно построить в Asynchronous model. Необходимо добавить время

**$\Omega$** - детектор, который eventually выбирает лидера (Leader Election), говорит всем узлам, что он жив и ему можно доверять, причём может сколько угодно раз ошибиться. Когда наконец лидер указан верно, начинает происходить прогресс. Можно доказать, что это самый слабый детектор, достаточный для решения консенсуса

У практического алгоритма Consensus есть Agreement - safety, выполняющееся всегда в асинхронной модели, и Termination - liveness, выполняющееся eventually, которое достигается при помощи таймаутов, где время используется для выбора лидера

Примечание. FLP можно перенести на shared memory в процессоре и показать, что на CAS (consensus number $= \infty$) можно построить произвольный wait-free объект

[↑ Содержание ↑](https://github.com/ddvamp/distributed-db-learning/tree/main/notes/dist-sys-mipt#содержание)\
[← Семинар 3](https://github.com/ddvamp/distributed-db-learning/blob/main/notes/dist-sys-mipt/seminars/seminar-3.md)
[Семинар 4 →](https://github.com/ddvamp/distributed-db-learning/blob/main/notes/dist-sys-mipt/seminars/seminar-4.md)
