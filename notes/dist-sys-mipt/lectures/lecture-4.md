## Lecture 4. Невозможность консенсуса, теорема FLP

В ABD на кворумах число отказов было f <= n/2, где n - нечётное. Но можно ли лучше. Сколько отказов способен пережить Consensus

Пусть есть произвольное количество узлов и три различных исполнения (мира) на них - E0, E1/2 и E1. В E0 все узлы предлагают на консенсус 0, а в E1 - 1. В E1/2 произошёл произвольный partition на части A и B, так что в A все узлы предлагают 0, а в B - 1. И пусть в мысленном разбиении на те же части в E0 умерли все узлы B, а в E1 - A, и в E1/2 отказов нет
Посмотрим на возможные поведения алгоритма консенсуса при соблюдении его свойств (Validity, Agreement, Termination). В E0 по алгоритму консенсуса выберут 0, в E1 выберут 1. И поскольку части A и B не видят отличий от исполнений E0 и E1, в них будут выбраны 0 и 1 соответственно. Узлы выбрали разные значения - потеряли Agreement, что приведёт к нарушению TO в AB и расходящимся репликам на уровне RSM. Здесь нет какой-то неучтённости, на уровне R-BCast-а partition в конечном итоге устранится, и сообщения будут eventually доставлены
Вывод: в случае любого partition-а алгоритм должен заблокироваться (потерять Termination) в одной из частей, и оптимальнее в меньшей. Минимальное значение по большей части любого partition это majority. Следовательно, алгоритм консенсуса не должен пережить не более половины отказов. Если переживать больше отказов, то в случае partition меньшая часть не поймёт, что другие узлы всё ещё живы, и продолжит работать. Выражаясь иначе, при большом числе отказов Agreement и Termination несовместимы

Алгоритму/Узлам не нужно знать число отказов. В действительности partition-ы возможны одновременно с отказами и другими partition-ами, поэтому при partition-е могут остановиться обе части. Алгоритм консенсуса продолжает работать, покуда в связной части системы собирается кворум

Половина отказов - первое ограничение алгоритма консенсуса. Второе рассмотрим в следующих условиях
- Asynchronous Model
- Deterministic Algorithm - может быть устроен по разному на разных узлах, но он детерминирован
- f <= 1
Утверждается, что в таких ограничениях невозможно построить алгоритм консенсуса с тремя его свойствами, и поскольку корректный алгоритм не может нарушить Validity + Agreement, построенный не сможет завершиться. Докажем это

Теорема FLP (Fischer, Lynch, Paterson, 85)
В Asynchronous Model даже в случае одного отказа никакой детерменированный корректный алгоритм консенсуса не способен гарантировать Termination во всех исполнениях (спойлер, нужна Partially Synchronous Model)

Док-во. Представим произвольный алгоритм консенсуса в виде графа его всевозможных исполнений. Узел графа есть мгновенный снимок состояния мира - Configuration = nodes + network (состояние всех узлов и сети, т.е. содержимое памяти, дисков, регистров, RIP, ядер, проводов и летящих по ним сообщений). Исполнение алгоритма характеризуется переходами между конфигурациями
Пусть в конфигурации C следующим будет доставлено сообщение m для узла p ((m, p) in Net(C)), тогда переход C -> C' будет означать доставку m, где C' - конфигурация мира после всех реакций узла p на сообщение (изменение состояния, отправка других сообщений и пр.). Для целей доказательства считаем переходы мгновенными (что в действительности не так). Одновременно в сети может находиться множество сообщений, столько же будет возможных переходов в графе из узла конфигурации
Есть начальные конфигурации. Путь в графе отражает некоторое исполнение. Отказ узла означает, что с некоторого момента путь не может заходить в конфигурации, связанные с этим узлом. Берём на себя роль Adversary и выбираем путь. Теорема утверждает, что мы можем ходить вечно, однако как честный Adversary мы обязаны eventually доставить каждое отправленное сообщение, то есть не можем в конфигурации с единственным переходом игнорировать его (за исключением случая, когда это сообщение для умершего узла). Значит достаточно найти цикл в графе, в котором участвуют все сообщения, имеющиеся в сети в момент попадания в него

Сделаем случай ещё более частным: консенсус бинарный - предлагают 0 или 1
Два вида конфигурации
- бивалентная - конфигурация без предопределённого выбора, где в зависимости от дальнейшего пути могут выбрать как 0, так и 1
- унивалентная - конфигураци с предопределённым выбором, который не зависит от дальнейшего пути. 0-val и 1-val конфигурации - выберут 0 или 1 соответственно
Необходимо доказать, что мы можем бесконечно ходить по бивалентным конфигурациям

Лемма 1. Какой бы алгоритм консенсуса мы не взяли, существует такой набор входных значений, для которого алгоритм консенсуса не знает заранее что он выберет
От противного. Пусть все начальные конфигурации univalent, что означает детерминированный и предопределённый результат консенсуса для любого набора входных данных. Пусть C0=(0,0,...,0), C1=(1,0,...,0),..., Cn=(1,1,...,1) цепочка некоторых начальных состояний. В C0 выберут 0, в Cn выберут 1, Ci выбирает 0 или 1. Очевидно, что в цепочке найдётся пара (Ck-1, Ck) такая, что Ck-1 выберает 0, а Ck выберает 1. Они отличаются только значением на входе k-го узла, при смерти которого алгоритм каким-то образом должен отличить два исполнения, что невозможно. Значит должна быть начальная бивалентная конфигурация

Лемма 2. Из бивалентной конфигурации всегда можно перейти в бивалентную конфигурацию
Начинаем из C - bivalent, и есть произвольное (m, p) in Net(C), e - событие доставки сообщения m, S - множество конфигураций достижимых из C без доставки m, Se - множество конфигураций достижимых из S одним переходом по событию e. И мы не собираемся убивать узел p, значит любое исполнение eventually пройдёт через одну из конфигураций Se. Согласно лемме в Se существует бивалентная конфигурация C'
От противного. Пусть в Se любая конфигурация univalent
Шаг 1. В Se найдётся хотя бы по одной 0-val и 1-val конфигурации. Допустим, все конфигурации в Se 0-val. Поскольку мы обязаны попасть Se, и на любом пути алгоритм неизбежно выберет 0, C - univalent. Противоречие
Шаг 2. В S найдётся пара конфигураций C' и C'' таких, что C' -> C'' при событии e' (m', p') in Net(C'), C' -> 1-val при e и C'' -> 0-val при e (или наоборот 0 <-> 1). Допустим таких C' и C'' нет, тогда на любом пути из C' каждая последующая конфигурация из S будет также попадать в 1-val конфигурацию из Se. Но тогда там нет 0-val. Противоречие
Шаг 3. Из предыдущего невозможно, что p' != p. Допустим это так. События e и e' независимы, значит пары переходов ee' и e'e должны привести в одну и ту же конфигурацию. Последовательность событий e'e приводит в 0-val, однако событие e приводит в 1-val, а значит при ee' должен существовать переход из 1-val в 0-val, что невозможно
Значит p' == p. Виртуально убив узел p и задержав ему все сообщения, рассмотрим некоторый путь из C'. Допустим, он завершается в 1-val. Приложим этот же путь к 0-val и 1-val конфигурациям из шага 2, также задержав сообщения от p, которые тот послал при e и e'. Поскольку для всех узлов кроме p разницы нет, оба пути должны прийти к 1-val. Это значит, что на пути через C'' произошёл переход от 0-val к 1-val, что снова невозможно
Суммируя, по лемме 2, если в Se нет бивалентных конфигураций, то
1. в Se есть 0-val и 1-val
2. найдётся C'', переход к которой меняет итоговую валентность
3. найдётся путь через C'', на котором меняется предопределённая валентность
Противоречие, значит в Se найдётся бивалентная конфигурация

В итоге, если начать в бивалентной конфигурации (по лемме 1), то можно бесконечно выбирать самое старое сообщение, ведущее в бивалентную конфигурацию (по лемме 2), и получить livelock
Теорема говорит, что даже если в системе нет отказов, но возможны, то консенсус может завершаться сколь угодно долго, потому что в асинхронной модели система не может отличить сбойный узел от медленного

Итог
Теорема о partition говорит, что при majority отказов теряется Agreement. Мы не можем завершиться. Нет safity ~ deadlock
Теорема FLP говорит, что при возможности (не наличия) сбоев теряется Termination. Мы можем не завершиться. Нет liveness ~ livelock

Наблюдения
Удобно и полезно при построении алгоритма консенсуса или просматривая чужой искать livelock, иначе алгоритм некорректен
Если система использует алгоритм консенсуса, у неё есть периоды недоступности, на которые никак не повлиять

Как преодолеть FLP - перейти в частично синхронную модель с предположениями о времени. Суть проблемы в том, что алгоритм консенсуса неспособен отличить сбойный узел от медленного. В частично синхронной модели существуют периоды времени, которые помогают алгоритму завершиться. Именно поэтому нужны таймауты, таймеры, периодические Heartbeat-ы. Это инженерное решение, не математическое
Время (таймауты) нужно чтобы определять сбои. Можно свести Consensus -> Failure Detector (задача построения детектора сбоев), и думать в каких предположениях о времени строится детектор сбоев, а не находится консенсус, для которого думать, каких гарантий ему достаточно от детектора
Failure Detector - компонент, который находится на каждом узле и умеет отвечать на вопрос (возможно, ошибочно), жив ли какой-то другой узел. Невозможно построить в async model по FLP. Необходимо добавить время
Omega - детектор, eventually выбирает лидера (Leader Election), говорит на всех узлах что он жив и ему можно доверять, причём может сколько угодно раз ошибиться. Как только лидер указан верно, происходит прогресс. Является самым слабым для решения консенсуса

У практического алгоритма Consensus есть Agreement - safety, выполняющееся всегда в асинхронной модели, и Termination - liveness, выполняющееся eventually, которое достигается при помощи таймаутов, где время используется для выбора лидера

Заметка: FLP переносится на shared memory в процессоре, где доказано, что на CAS (consensus = inf) можно построить произвольный wait-free объект

[↑ Содержание ↑](https://github.com/ddvamp/distributed-db-learning/tree/main/notes/dist-sys-mipt#содержание)\
[← Семинар 3](https://github.com/ddvamp/distributed-db-learning/blob/main/notes/dist-sys-mipt/seminars/seminar-3.md)
[Семинар 4 →](https://github.com/ddvamp/distributed-db-learning/blob/main/notes/dist-sys-mipt/seminars/seminar-4.md)
