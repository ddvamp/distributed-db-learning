## Lectures 5. Single-Decree Paxos

Single-Decree Paxos (Paxos одного указа) - алгоритм поиска консенсуса в изоляции, описанный в статье Paxos Made Simple. Является единичным шагом алгоритма Multi-Paxos (статья The Part-Time Parliament), который реализует сразу A-BCast. Raft - более интуитивный аналог Paxos с инкрементальным объяснением (Paxos нет), в котором можно провести декомпозицию на независимые части. Лучше начать с изучения его

Постановка задачи Consensus
Пусть есть n узлов, и каждый предлагает своё значение vi. Необходимо реализовать на каждом узле процедуру Propose(vi) -> v* со свойствами
- Validity - v* in {v}
- Agreement - на всех узлах v* одинаков
- Termination - алгоритм eventually завершится

Single-Decree Paxos выделяет две роли узлов (Roles)
- Proposer (P) - активен, выдвигает предложение через Propose
- Acceptor (A) - пассивен, голосует за предложение одного из P. Свободен менять свой выбор в процессе
Каждый узел может иметь как одну из ролей, так и обе сразу

Предложение (Proposal или Ballot) есть пара (n, v), где n - номер предложения (или бюллетени, Ballot number), v - предлагаемое значение. Все Ballot number уникальны, монотонны для отдельных P, но не среди всех, и глобально упорядочены (линейный порядок). Поэтому Ballot number есть пара (k, id), где k - линейный счётчик, id - уникальный идентификатор Proposer-а. Каждый узел надёжно хранит Ballot number на Disk-е

Proposer-ов может быть сколько угодно. Acceptor-ов будет фиксированное число, от которого зависит отказоустойчивость. Общения P-P/A-A нет. Только P-A. Proposer посылает сообщение, Acceptor на него реагирует. Proposer-ы конкурентно делают предложения, из которых Acceptor-ы должны согласованно сделать выбор. Очень условно можно сказать, что Proposer пытается собрать кворум распределённых блокировок (Lease) над Acceptor-ами и сделать им предложение

Lease - распределённая блокировка, которая выдаётся на ограниченное время, которое узел может продлевать, сообщая что он жив

Алгоритм Propose(v)

P - координатор выбора, A - голосующий элемент (память), способный умереть. Состояние A: np - максимальный увиденный n, (na, va) - текущий отданный голос (Vote), может замениться голосом с большим na
Две фазы Propose(v)
- захватить внимание A ("взять блокировку")
- сделать предложение
Фаза 1. P выбирает очередной n и отправляет всем A сообщение Prepare(n), по получению которого, если np <= n, то A обновляет np <- n и отвечает P сообщением Promise(np, (na, va)), иначе посылает nack (отказ). Promise суть обещание отклонять предложения с номерами меньше n. P собирает кворум из ответов Promise, с чем завершается фаза 1
Фаза 2. P смотрит на полученные Vote. Если все пустые (0, None) - начальное состояние, то v* это v, иначе v* это va с максимальным na. Теперь P отправляет всем A сообщение Propose(n, v*) (Accept(n, v*)), по получению которого, если np <= n, то A обновляет (np, (na, va)) <- (n, (n, v*)) и отвечает P сообщением Accepted(n), иначе посылает nack. Если кворум второй фазы успешен, v* есть результат Consensus-а
Для обеих фаз, если кворум не собрался, P выбирает следующий n и возвращается к фазе 1. nack (not ack) - сообщение отказа, которое содержит np. P определяет наибольший np из отказов и выбирает на его основе следующий n <- np + 1. Если же много A вышли из строя, P блокируется (safety)

Замечания
- Важно понимать, что P ждёт большинство ответов, а не большинство положительных ответов. Если есть хоть один nack, кворум не собрался, в любой из фаз. Нельзя ждать дополнительные ответы, в которых может быть не nack, поскольку так снижается отказоустойчивость
- Разные P не могут иметь одинаковый n. Более того, один и тот же n может быть использован строго единожды в фазе 1 и строго единожды в фазе 2. Если на A пришёл n = np, то это сообщение от того же P в том же раунде в фазе 2 после фазы 1
- Vote в Promise есть helping чтобы показать, за что A уже отдал голос, чтобы не выдвигать новый вариант (быстрее сойтись к единому решению)
- предложение выбрано (Chosen), когда majority A приняли Vote, т.е. ответили Accept (недостаточно, чтобы на majority был одинаковый v с разными n). При этом не обязательно, что Vote вообще будет лежать на большинстве Acceptor-ов в момент принятия решения, поскольку к этому моменту на части узлов он уже может быть перезаписан голосами с большим номером

Доказательство корректности

Validity
Validity следует из здравого смысла - значения не возникают из воздуха (если узлы и сеть честная, и нет багов)

Agreement
Пусть предложение (n, v) - chosen. Если в сети появится (или уже есть) Propose(n', v'), n' >= n, то v' = v. Док-во. Если n' = n, то это Propose того же узла в том же раунде, и очевидно v' = v. Пусть n' > n. Представим кворумы Propose(n, v) и Prepare(n'), оба успешны по постановке задачи. В их пересечении найдётся A - a* на котором в силу n < n' Propose произошел до Prepare (иначе a* не был бы частью обоих кворумов). Значит Prepare возьмёт значение либо из голоса (n, v), либо из голоса (n'', v''), где n'' > n, некоторого A, который не обязательно лежит в перечесении кворумов. Если это v'', то когда-то был Propose(n'', v''). Пришли к исходному. По принципу Дирихле, нельзя сколь угодно долго находить новый n* меньший предыдущего в конечном диапазоне [n, n'], а значит Prepare(*) возьмёт v(*) от (n, v) => v = v(*) = ... = v' => v' = v

Termination
По теореме FLP в алгоритме должен найтись livelock. В Paxos он называется Dueling proposers (дуэль) - два P мешают друг другу пройти через фазу 2. Суть проблемы в симметричности ситуаций для P - одинаковые синхронные таймауты до Retry. Для нарушения симметрии необходимо использовать Exponential Backoff со случайными начальной паузой и промежуточными добавками. Экспонента, поскольку достаточная пауза для успеха неизвестна. Рандом - для предотвращения волнообразной пиковой нагрузки одновременных Retry-ев. Альтернативой является устранение конкуренции за счёт выбора лидера (Leader Election) с использованием времени, который единолично будет инициировать консенсус

Именно потому, что корректность зависит от пересечения кворумов фазы 1 и фазы 2, фазы невозможно объяснить раздельно, нельзя применить инкрементальный подход (как в Raft)

Не обязательно выбирать размеры кворумов 1 и 2 фаз одинаковыми

Как узнать результат консенсуса. Нельзя собирать кворум чтения (результаты неоднозначны). Нужно стать Proposer-ом и предложить своё значение (попытаться завершить консенсус)

Преимущество алгоритма Paxos над Raft в том, что он не думает о времени. Он разделяет Safity и Liveness. Он только гарантирует корректность, но не termination, и если корректность соблюсти, можно как угодно использовать время, чтобы получить termination

На практике вместо задачи консенсуса сразу строят A-BCast, однако размышлять проще о серии консенсусов

[↑ Содержание ↑](https://github.com/ddvamp/distributed-db-learning/tree/main/notes/dist-sys-mipt#содержание)\
[← Семинар 4](https://github.com/ddvamp/distributed-db-learning/blob/main/notes/dist-sys-mipt/seminars/seminar-4.md)
[Семинар 5 →](https://github.com/ddvamp/distributed-db-learning/blob/main/notes/dist-sys-mipt/seminars/seminar-5.md)
