## Lectures 5. Single-Decree Paxos

Рассмотрим одно из решений задачи поиска консенсуса. **Single-Decree Paxos (Paxos одного указа)** - алгоритм поиска консенсуса в изоляции, описанный в статье *Paxos Made Simple*. Является единичным шагом алгоритма **Multi-Paxos** (статья *The Part-Time Parliament*), который сразу реализует $A-BCast$

#### Постановка задачи Consensus

Повторим постановку задачи из [лекции 3](https://github.com/ddvamp/distributed-db-learning/blob/main/notes/dist-sys-mipt/lectures/lecture-3.md#consensus). Пусть есть множество узлов, каждому на вход подали $v_i$, и каждый узел должен реализовать процедуру $` Propose \left \lparen v_i \right \rparen \to v^{*} `$ со свойствами
- **Validity** - $` v^{*} \in \{v_i\} `$
- **Agreement** - на всех узлах $` v^{*} `$ одинаков
- **Termination** - алгоритм eventually завершается

#### Роли в Single-Decree Paxos

Single-Decree Paxos выделяет две **роли (Roles)** узлов
- **Proposer** - активен, выдвигает предложение через $Propose$
- **Acceptor** - пассивен, голосует за предложение одного из Proposer-ов. Может поменять свой голос в процессе работы алгоритма

Любой узел может иметь как одну из ролей, так и обе сразу

**Предложение (Proposal или Ballot)** есть пара $` \left \lparen n, v \right \rparen `$, где $n$ - **номер предложения (или бюллетени, Ballot number)**, $v$ - предлагаемое значение. Все Ballot number глобально уникальны, монотонны для отдельных Proposer-ов, но не среди всех, и глобально упорядочены (линейный порядок). Поэтому Ballot number есть пара $` \left \lparen k, id \right \rparen `$, где $k$ - линейный счётчик, $id$ - уникальный идентификатор Proposer-а. Каждый узел надёжно хранит Ballot number на Disk-е

Proposer-ов (предложений) может быть сколько угодно, Acceptor-ов будет фиксированное число, от которого зависит отказоустойчивость. Сообщения идут лишь от Proposer-ов к Acceptor-ам, на что последние реагируют. Сообщений для Proposer-ов или от Acceptor-ов нет. Proposer-ы конкурентно делают предложения, из которых Acceptor-ы должны согласованно выбрать одно. Очень условно можно сказать, что все Proposer-ы одновременно пытаются собрать кворум распределённых блокировок (*Lease*) над Acceptor-ами и сделать им предложение. **Lease** - распределённая блокировка, которая выдаётся на ограниченное время, которое узел может продлевать, сообщая что он жив

#### Описание алгоритма Propose

$P$ - координатор выбора, $A$ - голосующий элемент (память), способный умереть. $A$ хранит $n_p$ - максимальный увиденный им $n$, и $` \left \lparen n_a, v_a \right \rparen `$ - текущий отданный **голос (Vote)**, который может быть заменён голосом с большим $n$. Алгоритм (действия $P$) состоит из *двух фаз*
- захватить внимание $A$ ("взять блокировку")
- сделать предложение

*Фаза 1.* $P$ выбирает очередной $n$ и отправляет всем $A$ сообщение $` Prepare \left \lparen n \right \rparen `$, при получении которого $A$, если $` n \gt n_p `$, обновляет $n_p \gets n$ и посылает $P$ в ответ $` Promise \left \lparen n_p, \left \lparen n_a, v_a \right \rparen \right \rparen `$ - обещание отклонять предложения $Accept$ с номерами меньше $n$, иначе посылает $nack$ (not ack, отказ). $P$ собирает кворум из $Promise$, с чем завершается фаза $1$

*Фаза 2.* $P$ смотрит на полученные $Vote$. Если все пустые $` \left \lparen 0, None \right \rparen `$ - начальное состояние, то $` v^{*} `$ это $v$, иначе $` v^{*} `$ это $v_a$ с максимальным $n_a$. Теперь $P$ отправляет всем $A$ сообщение $` Propose \left \lparen n, v^{*} \right \rparen `$ ($` Accept \left \lparen n, v^{*} \right \rparen `$), при получении которого $A$, если $` n \ge n_p `$, обновляет $` \left \lparen n_p, \left \lparen n_a, v_a \right \rparen \right \rparen \gets \left \lparen n, \left \lparen n, v^{*} \right \rparen \right \rparen `$ и посылает $P$ в ответ $` Accepted \left \lparen n \right \rparen `$, иначе посылает $nack$. $P$ собирает кворум из $Accepted$, и, если успешно, $` v^{*} `$ есть результат консенсуса

Для обеих фаз, если кворум не собрался, $P$ выбирает следующий $n$ и возвращается к фазе $1$. $nack$ - сообщение отказа, которое содержит $n_p$. $P$ определяет наибольший $n_p$ из отказов и выбирает на его основе следующий $` n \gets n_p + 1 `$. Если же много $A$ вышли из строя, $P$ блокируется

#### Примечания к алгоритму

1. На уровне реализации $P$ фьючи запросов имеют лишь два возможных результата, ответ и отказ. Ошибки, в том числе таймауты, спрятаны на уровне реализации канала
2. Из предыдущего, в реализации $P$ собирает кворум фьюч, а не кворум положительных ответов. Оставшиеся фьючи при этом отменяют. Если есть хоть один $nack$, фаза не удалась. Нельзя ждать дополнительные ответы из-за $nack$, поскольку так снижается отказоустойчивость (оставшиеся фьючи могут никогда не сработать из-за бесконечных ретраев внутри по отказам)
3. Разные $P$ не могут и не должны иметь одинаковый $n$. Более того, конкретный $n$ может быть использован строго единожды в фазе $1$ и строго единожды в фазе $2$. Если на $A$ пришёл $n = n_p$, значит это сообщение в фазе $2$ после фазы $1$ того же раунда от того же $P$
4. Обновление $A$ значения $n$ есть механизм предотвращения перезаписи уже выбранного значения другим
5. $Vote$ в $Promise$ есть helping, чтобы быстрее сойтись к единому решению. Как только все $A$ впервые отдали голос, новых в системе не возникнет, и со временем их число будет уменьшаться вплоть до одного
6. Предложение выбрано (Chosen, "конфигурация univalent"), когда впервые majority $A$ приняли $Vote$, т.е. послали $Accept$. Недостаточно, чтобы на majority $A$ был одинаковый $v$ с разными $n$. При этом не обязательно, что $Vote$ вообще будет лежать на majority $A$ в момент принятия решения, поскольку к этому моменту на части узлов он уже может быть перезаписан $Vote$ с большим $n$, но по Agreement с тем же $v$
7. Из $2$ и $6$ возможна ситуация, когда отказы обгоняют положительные ответы других $A$, и $P$ переходит к новой фазе, спровоцировав аналогичную ситуацию для других $P$. Т.о., даже когда в системе осталось единственное значение, $P$ могут долгое время не понимать этого и продолжать посылать с ним голоса всё с большими $n$. **Это идеальный пример FLP**

#### Доказательство свойств

*Validity.* Из здравого смысла, если узлы и сеть честные, и нет багов, значения не могут возникнуть из воздуха

*Agreement.* Пусть предложение $` \left \lparen n, v \right \rparen `$ - chosen, тогда с этого момента в сети для любого $` Propose \left \lparen n^{'}, v^{'} \right \rparen, n^{'} \ge n: v^{'} = v `$. Доказательство. Если $` n^{'} = n `$, то это $Propose$ того же узла в том же раунде для одного из оставшихся $A$, и, очевидно, $` v^{'} = v `$. Пусть $` n^{'} \gt n `$. Представим кворумы $` Propose \left \lparen n, v \right \rparen `$ и $` Prepare \left \lparen n^{'} \right \rparen `$. Они оба успешны, первый по предусловию, второй по наличию $Propose$. В их пересечении найдётся $` A - a^{*} `$, на котором, в силу $` n \lt n^{'} `$, $Propose$ произошел до $Prepare$ (иначе $` a^{*} `$ не был бы частью обоих кворумов). Значит $Prepare$ возьмёт значение либо из голоса $` \left \lparen n, v \right \rparen `$, либо из голоса $` \left \lparen n^{''}, v^{''} \right \rparen `$, где $` n \lt n^{''} \lt n^{'} `$, некоторого $A$, который не обязательно лежит в перечесении кворумов. Если это $` v^{''} `$, то когда-то был $` Propose \left \lparen n^{''}, v^{''} \right \rparen `$. Пришли к исходному. По принципу Дирихле, нельзя сколь угодно долго находить новый $` n^{*} `$ меньший предыдущего в конечном диапазоне $` \left \lbrack n, n^{'} \right \rbrack `$, а значит некоторый $` Prepare^{*} `$ возьмёт $` v^{*} `$ от $` \left \lparen n, v \right \rparen \to v = v^{*} = \dots = v^{'} \Rightarrow \boxed{v^{'} = v} `$

*Termination.* По теореме FLP в алгоритме должен найтись livelock. В Paxos он называется **Dueling proposers (дуэль proposer-ов)** - два $P$, приходя со всё большими $n$, мешают друг другу закончить фазу $2$. Суть проблемы в симметричности ситуаций для $P$ - одинаковое время выполнения раунда. Для нарушения симметрии необходимо использовать *Exponential Backoff* со случайными начальной паузой и промежуточными добавками. Экспонента, поскольку достаточная пауза для успеха неизвестна. Рандом - для предотвращения волнообразной пиковой нагрузки одновременных Retry-ев. Альтернативой является устранение конкуренции за счёт выбора лидера (Leader Election) с использованием времени, который единолично будет инициировать консенсус

#### Итоговые примечания

1. Из-за того, что корректность зависит от пересечения кворумов фазы $1$ и фазы $2$, их невозможно объяснить раздельно, а алгоритм построить инкрементально. В MultiPaxos фазы получают больше смысла
2. Не обязательно выбирать размеры кворумов $1$ и $2$ фаз одинаковыми (TODO: в чём смысл)
3. Чтобы прочесть значение нельзя собирать кворум чтения, поскольку результаты неоднозначны. Нужно стать Proposer-ом и предложить своё значение (TODO: что делать, если в начале все ответы содержат None, и действительно придётся что-то записать)
4. Преимущество алгоритма Paxos над **Raft** (альтернативный алгоритм поиска консенсуса) в том, что он не думает о времени. Он разделяет Safity и Liveness, гарантирует корректность, но не termination, и если корректность соблюсти, можно как угодно использовать время, чтобы получить termination, будь то встроить таймауты или реализовать детектор сбоев
5. На практике вместо задачи консенсуса сразу строят $A-BCast$, однако размышлять проще о серии консенсусов, с чего и начинается следующая лекция

[↑ Содержание ↑](https://github.com/ddvamp/distributed-db-learning/tree/main/notes/dist-sys-mipt#содержание)\
[← Семинар 4](https://github.com/ddvamp/distributed-db-learning/blob/main/notes/dist-sys-mipt/seminars/seminar-4.md)
[Семинар 5 →](https://github.com/ddvamp/distributed-db-learning/blob/main/notes/dist-sys-mipt/seminars/seminar-5.md)
